#include "{{module_name}}.hpp"
#include <emscripten/val.h>
#include <emscripten/bind.h>
#include <iostream>
#include <fstream>
#include <vector>

using namespace emscripten;

// Private implementation (pImpl pattern)
class {{module_name}}Module::Impl {
public:
    val module;
    val instance;
    val exports;
    
    bool loadWasmModule(const std::string& path) {
        try {
            // Read the WebAssembly binary file
            std::ifstream file(path, std::ios::binary | std::ios::ate);
            if (!file) {
                std::cerr << "Error: Could not open WebAssembly file: " << path << std::endl;
                return false;
            }
            
            std::streamsize size = file.tellg();
            file.seekg(0, std::ios::beg);
            
            std::vector<uint8_t> buffer(size);
            if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
                std::cerr << "Error: Could not read WebAssembly file" << std::endl;
                return false;
            }
            
            // Create the WebAssembly module
            module = val::global("WebAssembly").call<val>("Module", val(typed_memory_view(buffer.size(), buffer.data())));
            
            // Create imports object (for any imports required by Rust module)
            val imports = val::object();
            
            // Instantiate the module
            instance = val::global("WebAssembly").call<val>("Instance", module, imports);
            
            // Get the exports
            exports = instance["exports"];
            
            return true;
        } catch (const std::exception& e) {
            std::cerr << "Error loading WebAssembly module: " << e.what() << std::endl;
            return false;
        }
    }
};

// Constructor and destructor
{{module_name}}Module::{{module_name}}Module() : pImpl(std::make_unique<Impl>()) {}
{{module_name}}Module::~{{module_name}}Module() = default;

// Load method
bool {{module_name}}Module::load(const std::string& path) {
    return pImpl->loadWasmModule(path);
}

// Exported function implementations
{{#each functions}}
{{{cpp_return_type}}} {{../module_name}}Module::{{name}}({{#each args}}{{{cpp_type}}} {{name}}{{#unless @last}}, {{/unless}}{{/each}}) {
    try {
        {{#if (eq return_type "String")}}
        val result = pImpl->exports["{{name}}"].call<val>("{{name}}"
            {{#each args}}
            {{#if (eq rust_type "String")}}
            , val({{name}})
            {{else if (eq rust_type "&str")}}
            , val({{name}})
            {{else}}
            , {{name}}
            {{/if}}
            {{/each}}
        );
        return result.as<std::string>();
        {{#if (eq return_type "()")}}
        pImpl->exports["{{name}}"].call<void>("{{name}}"
            {{#each args}}
            {{#if (eq rust_type "String")}}
            , val({{name}})
            {{else if (eq rust_type "&str")}}
            , val({{name}})
            {{else}}
            , {{name}}
            {{/if}}
            {{/each}}
        );
        {{/if}}
        return pImpl->exports["{{name}}"].call<{{cpp_return_type}}>("{{name}}"
            {{#each args}}
            {{#if (eq rust_type "String")}}
            , val({{name}})
            {{else if (eq rust_type "&str")}}
            , val({{name}})
            {{else}}
            , {{name}}
            {{/if}}
            {{/each}}
        );
        {{/if}}
    } catch (const std::exception& e) {
        std::cerr << "Error calling Rust function {{name}}: " << e.what() << std::endl;
        {{#unless (eq return_type "()")}}
        return {{{cpp_return_type}}}{}; // Return default value
        {{/unless}}
    }
}
{{/each}}